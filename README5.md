Лабораторная работа 5
1) Сортировка выбором (Selection Sort) — это алгоритм сортировки, который находит наименьший (или наибольший) элемент в массиве и перемещает его в начало (или конец). Процесс повторяется, пока все элементы не окажутся упорядоченными. 
Алгоритм состоит из двух циклов:
	Внешний цикл: выбирает позицию в массиве, начиная с первой (нулевой).
	Внутренний цикл: сравнивает выбранный элемент с остальными элементами массива справа и находит минимальное значение. После завершения внутреннего цикла найденный минимум меняется местами с первым элементом текущего участка массива.
Таким образом, каждый проход внешнего цикла помещает наименьший оставшийся элемент на свою правильную позицию в начале массива.
________________________________________
Важные моменты:
	Алгоритм эффективен для небольших массивов.
	Сложность по времени составляет O(n²), где n — количество элементов в массиве.
	Это нестабильная сортировка, поскольку одинаковые элементы могут менять порядок относительно друг друга.
________________________________________
Пример вывода:
Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64
________________________________________
Анализ алгоритма: Сортировка выбором (Selection Sort)
Определение:
Сортировка выбором — это алгоритм, который последовательно выбирает минимальный элемент из неотсортированной части массива и переносит его в отсортированную часть.
Анализ:
	Разделяет массив на отсортированную и неотсортированную части.
	На каждой итерации внешнего цикла находит минимальный элемент в неотсортированной части и меняет его с первым элементом.
	Внешний цикл выполняется n-1 раз.
	Внутренний цикл проходит по всей оставшейся части массива.
  ________________________________________
Временная сложность:
	Количество сравнений примерно равно (n(n-1))/2.
	Сложность алгоритма: O(n^2).
  ________________________________________
Почему O(n^2):
Два вложенных цикла приводят к квадратичному росту количества операций по мере увеличения размера массива.
________________________________________
2) Сортировка пузырьком (также известна как «сортировка методом обмена») — простой алгоритм сортировки, основанный на попарном сравнении соседних элементов. Принцип работы: во время каждого прохода по списку (или массиву) алгоритм сравнивает две соседние позиции. Если элемент слева больше (или, в зависимости от порядка сортировки, меньше) элемента справа, происходит обмен местами. Проход продолжается, пока не будут проверены все пары соседних элементов
________________________________________
Пояснение КОДА:
Метод main:Здесь создаётся простой целочисленный массив, отображаются его элементы до сортировки, выполняется сама сортировка методом пузырька, и снова показываются элементы после завершения процесса.
Метод bubbleSort:Этот метод реализует основную логику пузырьковой сортировки.Алгоритм работает следующим образом:
	Во внешней петле (for) мы проходим по каждому элементу массива.
	Во внутренней петле проверяется условие: если левый элемент больше правого, то элементы меняются местами («всплывают»).
	Для оптимизации введён дополнительный флаг (swapped), который позволяет досрочно завершить процесс, если массив уже отсортирован.
Метод printArray:Простая вспомогательная функция для удобного вывода элементов массива на экран.
Метод swap:Используется для замены значений двух соседних элементов массива.
________________________________________
Код производит следующую последовательность действий:
	Создание исходного массива: {64, 34, 25, 12, 22, 11, 90}
	Вывод массива до сортировки:Исходный массив:64 34 25 12 22 11 90
	Выполнение сортировки методом пузырька. После завершения сортировки:
	Вывод отсортированного массива:Отсортированный массив:11 12 22 25 34 64 90
________________________________________
Анализ алгоритма:
Временная сложность:
Лучшая ситуация (O(n)):
	Когда массив изначально отсортирован. Тогда внутренний цикл сделает всего одну проверку и завершится сразу же благодаря проверке условия на наличие перестановок.
Средняя и худшая ситуации (O(n²)):
	Обычно пузырьковая сортировка требует полного прохода по всем элементам, причем даже если массив почти отсортирован, потребуется значительное число операций сравнения и возможных замен.
	Общий объем вычислений пропорционален количеству парных сравнений и изменений порядка элементов, что составляет около n^2/2 операций.
________________________________________
Почему O(n²)?
	Основная причина временной сложности заключается в наличии двух вложенных циклов:
	Внешний цикл совершает (n-1) итерации.
	Внутренний цикл в самом плохом сценарии (неупорядоченном массиве) выполняет полную проверку оставшихся элементов (n-i раз), начиная с полной длины и уменьшаясь на единицу при каждом проходе внешнего цикла.
	Суммарно общее количество проверок и возможных замещений растет пропорционально квадрату размера массива, отсюда временная сложность O(n²).

3) Сортировка вставками (Insertion sort) — алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.
Программа выведит:
Массив до сортировки: [64, 34, 25, 12, 22, 11, 90]
Массив после сортировки: [11, 12, 22, 25, 34, 64, 90]
Анализ работы алгоритма:
	Идея алгоритма:
	Мы рассматриваем массив как состоящий из двух частей: левой отсортированной и правой неотсортированной.
	Начиная со второго элемента, берем текущий элемент и пытаемся вставить его в правую позицию в отсортированном сегменте.
	Чтобы сделать это, элементы отсортированного сегмента двигаются вперед, если они больше текущего элемента.
	Детали реализации:
	Используется два основных цикла:
	Внешний цикл: проходит по каждому элементу массива, начиная со второго (индекс 1).
	Внутренний цикл: двигается назад по отсортированной части массива, сравнивая элементы и двигая их вперед, пока не найдет подходящую позицию для вставки текущего элемента.
	Особенности реализации:
	Каждое сравнение ведет либо к замене элементов, либо к сохранению прежнего положения.
	Таким образом, каждая новая итерация расширяет отсортированную область массива.
________________________________________
Временная сложность:
	Лучшая ситуация (O(n)): Когда массив уже отсортирован, внутренний цикл практически не выполняет никаких операций, потому что ни одно смещение не требуется.
	Средняя и худшая ситуации (O(n²)): Если массив расположен в обратном порядке или хаотично, придется многократно сравнивать и передвигать элементы, что даёт нам общую сложность порядка O(n^2).
________________________________________
Почему O(n²)?
	Причина в структуре двойного цикла:
	Внешний цикл проходит по всем элементам, кроме первого.
	Внутренний цикл на каждой итерации может пройти всю предыдущую отсортированную часть массива.
	Количество необходимых сравнений приблизительно равно сумме арифметической прогрессии от 1 до n-1, что приближенно выражается формулой ((n-1)n)/2, приводящей к общей временной сложности O(n^2).

4) Сортировка слиянием (англ. Merge sort) — алгоритм сортировки, основанный на принципе «разделяй и властвуй».Алгоритм сортировки слиянием состоит из двух основных этапов: Разделение — массив рекурсивно делится на две равные (или почти равные) части до тех пор, пока каждый подмассив не будет состоять из одного элемента. Слияние — подмассивы объединяются в отсортированном порядке, начиная с самых маленьких подмассивов.

Результат исполнения программы:
При запуске данной программы на экране появится следующее:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]
________________________________________
Описание работы программы:
	Разделение массива на две части:Первым делом массив делится пополам, и обе части рекурсивно сортируются отдельно друг от друга.
	Объединение отсортированных частей:После того как левая и правая половина отсортированы, осуществляется их объединение. Здесь используется техника "слияния": сначала сравниваются первые элементы обеих половинок, наименьший помещается в общий массив, и процедура продолжается дальше.
	Рекурсия заканчивается тогда, когда длина массива равна одному элементу, поскольку массив из одного элемента уже является отсортированным.
Принцип работы:
	Базовый случай рекурсии:Если массив состоит из одного элемента или пуст, он уже отсортирован.
	Деление массива:Массив разделяется на две равные (или почти равные) части.
	Рекурсивная сортировка:Обе полученные части рекурсивно сортируются.
	Объединение:После того как обе части отсортированы, они сливаются вместе в единое целое.
________________________________________
Под капотом алгоритма:
	Сначала массив делится на две части.
	Эти две части продолжают дробиться рекурсивно, пока не останутся отдельные элементы.
	Затем начинают происходить операции объединения (merge), при которых отсортированные подпоследовательности соединяются в единую отсортированную последовательность.
________________________________________
Временная сложность:
	Хуже/лучше/среднее время: Все случаи имеют одинаковую временную сложность O(Nlog⁡N), где N — количество элементов в массиве.
Почему O(Nlog⁡N)?
	Массив постоянно делится пополам на каждом уровне рекурсии. Число уровней деления равно 〖log⁡〗_2 N.
	На каждом уровне рекурсии происходит операция объединения, которая занимает линейное время O(N).
	Общая временная сложность получается произведением количества уровней (〖log⁡〗_2 N) и стоимости объединения на одном уровне (N), что и дает итоговую сложность O(Nlog⁡N).

5) Сортировка Шелла (англ. Shell sort) — алгоритм сортировки, усовершенствованный вариант сортировки вставками. Идея: сравнивать элементы, стоящие не только рядом, но и на определённом расстоянии друг от друга. Это позволяет быстро переставлять далёкие неупорядоченные пары значений (сортировка таких пар обычно требует большого количества перестановок, если используется сравнение только соседних элементов).
________________________________________
После запуска программы на экране появятся следующие строки:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]
________________________________________
Анализ:
	Основная идея:Сначала элементы массива группируются на большом расстоянии друг от друга и сортируются локально. Затем это расстояние сокращается, и вновь проводится сортировка этих новых подгрупп. Наконец, когда дистанция достигает нуля, алгоритм сводится к обычной сортировке вставками, но массив уже значительно ближе к финальной отсортированной форме.
	Прохождение массива:  
	Внешний цикл контролирует уменьшение интервала (gap), на котором происходят операции сортировки.
	Подгруппы формируются таким образом, что берутся элементы, расположенные на расстоянии "gap" друг от друга.
	Чем меньше становится "gap", тем точнее выравнивается порядок элементов.
	Эффективность:За счет предварительного сглаживания порядка элементов до стадии обычных вставочных операций, скорость сортировки существенно возрастает по сравнению с классической сортировкой вставками.
________________________________________
Временная сложность:
	Средняя сложность:В среднем, сортировка Шелла обладает лучшей производительностью по сравнению с простыми методами типа сортировки вставками, выбором или пузырьком. Однако точное значение зависит от последовательности уменьшения промежутков (gap sequence). Типичные оценки варьируют от O(N^(3/2)) до O(N(log⁡N)^2) или даже лучше, в зависимости от используемой стратегии изменения расстояния между элементами.
	Худший случай:Теоретически возможен случай, когда время работы ухудшается до O(N^2), хотя это крайне редко встречается на практике.
________________________________________
Почему именно такая сложность?
	Использование предварительно сглаженной структуры (частичных сортировок на удалённых элементах) значительно снижает среднее количество необходимых перемещений элементов.
	Конкретная оценка производительности сильно зависит от выбранной последовательности изменения промежутков (например, наиболее эффективные последовательности дают лучшее поведение алгоритма).
Сортировка Шелла часто применяется там, где важна устойчивость и относительная простота реализации, обеспечивая заметное ускорение по сравнению с примитивными сортировочными алгоритмами.

6) Быстрая сортировка (QuickSort) — алгоритм сортировки, основанный на принципе «разделяй и властвуй». Применение: быстрая сортировка используется в ситуациях, где важна высокая скорость сортировки, особенно когда объём данных велик
программа выведет 
Исходный массив:
10 7 8 9 1 5
Отсортированный массив:
1 5 7 8 9 10
Принцип работы:
	Выбор опорного элемента:В данном примере опорный элемент выбирается как последний элемент массива.
	Разбиение массива:Все элементы, меньшие или равные опорному, перемещаются в левую часть массива, а все элементы, большие опорного, — в правую.
	Рекурсия:Процесс повторяется для левой и правой частей массива, пока весь массив не будет отсортирован.
________________________________________
Временная сложность:
	Лучший случай:Временная сложность равна O(Nlog⁡N), когда массив уже отсортирован или почти отсортирован.
	Средний случай:Временная сложность также равна O(Nlog⁡N), что делает алгоритм одним из самых эффективных для больших массивов.
	Худший случай:Временная сложность ухудшается до O(N^2), если массив уже отсортирован в обратном порядке или все элементы равны. Это происходит из-за неудачного выбора опорного элемента.
________________________________________
Почему именно такая сложность?
	В среднем случае алгоритм эффективно разделяет массив на две примерно равные части, что приводит к логарифмической глубине рекурсии.
	В худшем случае, если каждый раз опорный элемент оказывается крайним, массив делится на части размером 1 и N-1, что приводит к квадратичной сложности.
________________________________________
Таким образом, быстрая сортировка является одним из самых эффективных алгоритмов сортировки для больших объемов данных, но требует осторожного выбора опорного элемента для предотвращения ухудшения производительности.

7) Пирамидальная сортировка (Heap Sort, «Сортировка кучей») — алгоритм сортировки, основанный на структуре данных двоичной кучи. Алгоритм состоит из двух этапов: 1) Построение пирамиды из элементов исходного массива. Например, начиная с нулевого элемента последовательно заполняют уровни дерева слева направо: корень — нулевой элемент массива, его потомки — первый и второй элементы и т. д.. 2) Сортировка на построенной пирамиде. Из кучи извлекают один элемент и помещают его на освободившееся место в конце массива. После каждого извлечения пирамиду обновляют, чтобы сохранить
________________________________________
После запуска программы вы получите следующий результат:
Исходный массив: [12, 11, 13, 5, 6, 7]
Отсортированный массив: [5, 6, 7, 11, 12, 13]
________________________________________
Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
Принцип работы:
	Преобразование массива в кучу:Массив превращается в максимальную кучу (max-heap), где каждый родительский узел больше своих детей. То есть самый большой элемент находится в корне кучи.
	Удаление корней:Самый большой элемент (корень) ставится в конец массива, а оставшаяся часть массива повторно преобразуется в кучу, чтобы сохранить свойства кучи. Этот процесс повторяется до тех пор, пока весь массив не окажется отсортированным.
________________________________________
Временная сложность:
	Лучший, средний и худший случаи:Общая временная сложность алгоритма равна O(Nlog⁡N), где N — количество элементов в массиве.
	Почему именно такая сложность?Формирование начальной кучи требует O(N) операций. Удаление каждого элемента и восстановление свойств кучи занимают O(log⁡N) операций. Поскольку этот процесс повторяется N раз, итоговая сложность получается O(Nlog⁡N).
________________________________________
Таким образом, сортировка кучей является эффективным алгоритмом, который показывает хорошую производительность даже на больших объёмах данных, обладая стабильной временной сложностью O(Nlog⁡N).

8) Последовательный (линейный) поиск — это простейший вид поиска заданного элемента на некотором множестве, при котором каждый элемент проверяется по порядку до тех пор, пока не будет найден искомый элемент или не завершится просмотр всех элементов. 
________________________________________
При запуске программа выведет следующее сообщение:
Элемент 50 найден на позиции 4
________________________________________
Анализ алгоритма: Линейный поиск (Sequential Search).
Принцип работы:
	Алгоритм начинает просмотр с первого элемента массива и последовательно сравнивает каждое значение с искомым значением.
	Если совпадение найдено, возвращается индекс элемента.
	Если пройдены все элементы, а совпадение не обнаружено, возвращает специальное значение (-1), обозначающее отсутствие элемента в массиве.
________________________________________
Временная сложность:
	Лучший случай (элемент найден в первом сравнении):Временная сложность равна O(1).
	Средний и худший случаи (полный обход массива):Временная сложность равна O(N), где N — количество элементов в массиве.
________________________________________
Почему именно такая сложность?
	Алгоритм последовательно рассматривает каждый элемент массива, пока не найдет искомое значение или не просмотрит весь массив.
	Максимальное количество сравнений равно длине массива, поэтому временная сложность прямо пропорциональна размеру массива.
________________________________________
Таким образом, линейный поиск удобен своей простотой и отсутствием требований к предварительной обработке данных, но неэффективен для больших массивов.

9) Бинарный поиск (другие названия — двоичный поиск, метод половинного деления, дихотомия) — тип поискового алгоритма, который последовательно делит пополам заранее отсортированный массив данных, чтобы обнаружить нужный элемент
После запуска программа выведет следующее сообщение:
Значение 23 найдено на позиции 5
Принцип работы:
	Диапазон поиска задается границами low и high. Первоначально это начало и конец массива соответственно.
	На каждом шаге рассчитывается средняя точка mid, и происходит сравнение среднего элемента с искомым.
	Если средний элемент равен искомому, поиск завершен.
	Если средний элемент больше искомого, поиск продолжается в левой половине.
	Если средний элемент меньше искомого, поиск продолжается в правой половине.
	Такие шаги повторяются, пока не останется один элемент или не закончится диапазон поиска.
________________________________________
Временная сложность:
	Лучший случай (искомый элемент находится в середине):Временная сложность равна O(1).
	Средний и худший случаи (искаемый элемент отсутствует или находится на краю):Временная сложность равна O(log⁡N), где N — количество элементов в массиве.
________________________________________
Почему именно такая сложность?
	Алгоритм каждый раз делит диапазон поиска ровно пополам, что гарантирует экспоненциальное снижение размеров поиска.
	Так как после каждого шага размер области поиска уменьшается вдвое, максимальное количество шагов ограничено высотой двоичного дерева, равной 〖log⁡〗_2 N, где N — количество элементов в массиве.
	Соответственно, количество операций поиска зависит от логарифма размера массива, что дает временную сложность O(log⁡N).
________________________________________
Таким образом, бинарный поиск чрезвычайно эффективен для быстрого поиска в больших отсортированных списках.

10) Интерполяционный поиск (интерполирующий поиск) — алгоритм поиска, который основан на принципе поиска в телефонной книге или, например, в словаре.   Суть алгоритма: вместо сравнения каждого элемента с искомым, как при линейном поиске, интерполяционный поиск производит предсказание местонахождения элемента. Поиск происходит подобно двоичному поиску, но вместо деления области поиска на две части, интерполирующий поиск производит оценку новой области поиска по расстоянию между ключом и текущим значением элемента
После запуска программа выведет следующее сообщение:
Значение 23 найдено на позиции 5

Принцип работы:
	Итерационные шаги:
	Алгоритм определяет приблизительную позицию целевого элемента исходя из предположения, что распределение элементов равномерно.
	Новая позиция рассчитывается по формуле, учитывающей соотношение между текущими граничными элементами и целью.
	По полученной позиции алгоритм либо находит элемент, либо сужает диапазон поиска.
	Расчет позииции:
	Использует формулу для оценки вероятности местонахождения искомого элемента:
"pos"="low"+("target"-"arr"["low"])×("high" -"low" )/("arr" ["high" ]-"arr" ["low" ])

	Это позволяет быстрее находить цель, если распределение действительно близко к равномерному.
________________________________________
Временная сложность:
	Лучший случай (идеально равномерное распределение):Временная сложность равна O(log⁡log⁡N), где N — количество элементов в массиве.
	Средний случай (равномерное распределение):Временная сложность тоже близка к O(log⁡log⁡N).
	Худший случай (очень неравномерное распределение):Временная сложность может ухудшиться до O(N), если распределение элементов плохо предсказуемо или неоднородно.
________________________________________
Почему именно такая сложность?
	В отличие от бинарного поиска, который гарантированно уменьшает область поиска вдвое на каждом шаге, интерполяционный поиск потенциально способен гораздо быстрее добраться до нужного элемента при условии равномерного распределения.
	Но если распределение элементов резко меняется или является непредсказуемым, точность оценки позиций снижается, и алгоритм может оказаться менее эффективным, вплоть до прямой зависимости от размера массива.
________________________________________
Таким образом, интерполяционный поиск отлично проявляет себя на однородных данных, демонстрируя высокую скорость поиска.

11) Поиск Фибоначчи — это метод поиска в отсортированном массиве с использованием алгоритма «разделяй и властвуй», который сужает возможные местоположения с помощью чисел Фибоначчи. Вместо того чтобы вычислять середину, как в бинарном поиске, этот метод выбирает точки сравнения в списке. 
После запуска программа выведет следующее сообщение:
Значение 23 найдено на позиции 5
Принцип работы:
	Используя числа Фибоначчи, мы определяем точку разбиения массива, исходя из соотношения индексов соседних чисел Фибоначчи.
	На каждом шаге выбирается ближайшая возможная точка разбиения, соответствующая числу Фибоначчи, которая помогает определить следующую область поиска.
	Если выбранный элемент больше искомого, мы исследуем левую часть массива, иначе — правую.
	Такой подход теоретически позволяет ускорить поиск, если данные хорошо соответствуют распределению, характерному для чисел Фибоначчи.
________________________________________
Временная сложность:
	Лучший случай (точка поиска идеально соответствует ряду Фибоначчи):Временная сложность равна O(〖log⁡〗_ϕ (N)), где ϕ=(1+√5)/2≈1.618 — золотое сечение.
	Средний и худший случаи:Хотя в большинстве случаев алгоритм работает достаточно быстро, худшая временная сложность остается O(log⁡N), где N — количество элементов в массиве.
________________________________________
Почему именно такая сложность?
	На каждом шаге алгоритм разбивает массив на неравные части, одна из которых связана с числом Фибоначчи, позволяя быстрее локализовать поиск, если распределение данных благоприятствует такому подходу.
	Тем не менее, несмотря на потенциал ускорения, в худших случаях (особенно при неблагоприятных распределениях) алгоритм ведёт себя сходно с бинарным поиском, сохраняя логарифмическое время работы.
________________________________________
Таким образом, поиск Фибоначчи полезен в ситуациях, когда данные имеют особое распределение, схожее с рядом Фибоначчи, и в некоторых случаях может обеспечить преимущество над классическим бинарным поиском.

