Задание 4. Жадный алгоритм: покрытие множества
Условие. Дано семейство подмножеств. Выбрать минимальное число подмножеств,
покрывающих все элементы.
Алгоритм: жадный выбор подмножества с максимальным числом новых элементов.
Язык примера: Python
def set_cover(universe, subsets):
 covered = set()
 result = []
 while len(covered) < len(universe):
 best = None
 # ДОПИСАТЬ: найти подмножество с макс. числом непокрытых элементов
 result.append(best)
 covered.update(best)
 return result
Что дописать: перебор подмножеств и выбор лучшего.

____________________________________
Определение

Жадный алгоритм для задачи покрытия множества — это приближённый алгоритм, который на каждом шаге выбирает подмножество, покрывающее наибольшее количество ещё не покрытых элементов. Цель — найти минимальное количество подмножеств, которые полностью покрывают универсальное множество.

____________________
Объяснение работы алгоритма

covered = set() - Создается пустое множество для отслеживания покрытых элементов

result = [] - Инициализируется пустой список для выбранных подмножеств

while len(covered) < len(universe): - Цикл продолжается, пока не все элементы универсума покрыты

best_subset = None - Сбрасывается переменная для лучшего подмножества на текущей итерации

max_new_elements = 0 - Сбрасывается счетчик максимального количества новых элементов

for s in subsets: - Начинается перебор всех подмножеств

uncovered_in_s = s - covered - Для текущего подмножества вычисляются непокрытые элементы

num_new_elements = len(uncovered_in_s) - Подсчитывается количество новых элементов

if num_new_elements > max_new_elements: - Проверяется, дает ли это подмножество больше новых элементов

best_subset = s - Если да, запоминаем это подмножество как лучшее

max_new_elements = num_new_elements - Обновляем максимальное количество новых элементов

if best_subset is None: - Проверяем, было ли найдено подмножество с новыми элементами

break - Если нет, выходим из цикла (нельзя покрыть больше элементов)

result.append(best_subset) - Добавляем лучшее подмножество в результат

covered.update(best_subset) - Обновляем множество покрытых элементов

return result - Возвращаем найденный набор подмножеств
_______________
Временная сложность: O(n⋅m⋅k)

Обозначения:

n — размер universe (число элементов для покрытия);

m — число подмножеств в subsets;

k — максимальный размер одного подмножества.


Почему так:

Внешний цикл — до n итераций (каждый раз покрываем хотя бы один новый элемент).

На каждой итерации просматриваем все m подмножеств.

Для каждого подмножества выполняем операции (разность множеств, обновление) за O(k).


Итог:
n (итераций) × m (подмножеств) × k (операций на подмножество) =O(n⋅m⋅k)
_________________________________________
Контрольный вопрос 4. Жадный алгоритм вершинного покрытия

Почему жадный алгоритм для задачи о вершинном покрытии даёт 2-аппроксимацию? Приведите доказательство.

Жадный алгоритм вершинного покрытия гарантирует 2-аппроксимацию, поскольку он выбирает независимое множество рёбер и добавляет по 2 вершины к каждому ребру. Оптимальное покрытие должно содержать хотя бы одну вершину из каждого такого ребра, что обеспечивает соотношение ∣APPROX∣≤2⋅∣OPT∣.

Доказательство: пусть A — множество рёбер, выбранных алгоритмом (независимое множество). Любое вершинное покрытие должно содержать хотя бы одну вершину из каждого ребра в A, поэтому ∣OPT∣≥∣A∣. Жадный алгоритм добавляет по 2 вершины к каждому ребру из A, следовательно, ∣APPROX∣=2⋅∣A∣. Отсюда следует: ∣APPROX∣ = 2 ⋅ ∣A∣ ≤ 2 ⋅ ∣OPT∣.

Таким образом, коэффициент аппроксимации не превышает 2: (∣APPROX∣)/(∣OPT∣)≤2

Пример

Рассмотрим путь из трёх вершин a-b-c с рёбрами (a,b) и (b,c). Жадный алгоритм может выбрать ребро (a,b), добавить вершины a и b, затем выбрать ребро (b,c) и добавить вершины b и c. Итоговым покрытием будет {a,b,c} размером 3, а оптимальным покрытием — {b} размером 1. Коэффициент аппроксимации в этом случае равен 3, но это частный случай, который не нарушает общую гарантию 2-аппроксимации.
