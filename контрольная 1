1)	Работоспособный код на Python по алгоритму блочной (корзинной) сортировки:
def bucket_sort(arr):
    """
    Реализация блочной сортировки.

    Параметры:
    arr (list): Список чисел для сортировки.

    Возвращаемое значение:
    list: Отсортированный список.
    """
    if len(arr) == 0:
        return arr

    # Определяем минимальное и максимальное значения для расчета диапазона
    min_val = min(arr)
    max_val = max(arr)

    # Определяем количество корзин
    bucket_count = len(arr)
    buckets = [[] for _ in range(bucket_count)]

    # Распределяем элементы по корзинам
    for num in arr:
        # Определяем индекс корзины для текущего элемента
        index = int((num - min_val) / (max_val - min_val) * (bucket_count - 1))
        buckets[index].append(num)

    # Сортируем каждую корзину и объединяем результаты
    sorted_arr = []
    for bucket in buckets:
        # Сортируем каждую корзину, например, с помощью встроенной функции sorted
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)

    return sorted_arr


# Пример использования
if __name__ == "__main__":
    # Создаем тестовый массив
    array = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]

    print("Исходный массив:")
    print(array)

    # Сортируем массив
    sorted_array = bucket_sort(array)

    print("Отсортированный массив:")
    print(sorted_array)
После запуска программы на экране появится следующий результат:
Исходный массив:
[0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
Отсортированный массив:
[0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]
2) Реализация на Python алгоритма блинная сортировка

def pancake_sort(arr):
    """
    Реализация блинной сортировки.

    Параметры:
    arr (list): Список чисел для сортировки.

    Возвращаемое значение:
    list: Отсортированный список.
    """
    n = len(arr)
    unsorted_length = n

    while unsorted_length > 1:
        # Находим индекс максимального элемента в несортированной части массива
        max_index = arr.index(max(arr[:unsorted_length]))

        # Если максимальный элемент не на первой позиции, переворачиваем его на первую позицию
        if max_index != 0:
            arr[:max_index + 1] = reversed(arr[:max_index + 1])

        # Переворачиваем всю несортированную часть массива, чтобы максимальный элемент оказался на своем месте
        arr[:unsorted_length] = reversed(arr[:unsorted_length])

        # Уменьшаем длину несортированной части массива
        unsorted_length -= 1

    return arr

# Пример использования
if __name__ == "__main__":
    # Создаем тестовый массив
    array = [3, 6, 2, 7, 1, 5, 4]

    print("Исходный массив:")
    print(array)

    # Сортируем массив
    sorted_array = pancake_sort(array)

    print("Отсортированный массив:")
    print(sorted_array)
После запуска программы на экране появится следующий результат:
Исходный массив:
[3, 6, 2, 7, 1, 5, 4]
Отсортированный массив:
[1, 2, 3, 4, 5, 6, 7]

3) Сортировка Бусинами

def bead_sort(arr):
    """
    Реализация сортировки бусинами.

    Параметры:
    arr (list): Список чисел для сортировки.

    Возвращаемое значение:
    list: Отсортированный список.
    """
    if len(arr) == 0:
        return arr

    # Определяем максимальное значение в массиве
    max_val = max(arr)

    # Создаем вертикальные стержни
    beads = [[1 if arr[i] > j else 0 for j in range(max_val)] for i in range(len(arr))]

    # "Падение" бусин вниз
    for i in range(len(beads[0])):
        count = sum(beads[j][i] for j in range(len(beads)))
        for j in range(len(beads)):
            beads[j][i] = 1 if j < count else 0

    # Преобразование обратно в массив
    sorted_arr = [sum(beads[i]) for i in range(len(beads))]

    return sorted_arr

# Пример использования
if __name__ == "__main__":
    # Создаем тестовый массив
    array = [3, 6, 2, 7, 1, 5, 4]

    print("Исходный массив:")
    print(array)

    # Сортируем массив
    sorted_array = bead_sort(array)

    print("Отсортированный массив:")
    print(sorted_array)

После запуска программы на экране появится следующий результат:
Исходный массив:
[3, 6, 2, 7, 1, 5, 4]
Отсортированный массив:
[1, 2, 3, 4, 5, 6, 7]
4) Поиск скачками
import math

def jump_search(arr, x):
    """
    Реализация поиска скачками.

    Параметры:
    arr (list): Отсортированный список чисел.
    x (int): Искомое значение.

    Возвращаемое значение:
    int: Индекс элемента, если он найден, иначе -1.
    """
    n = len(arr)
    step = int(math.sqrt(n))

    # Находим блок, где может находиться искомый элемент
    prev = 0
    while arr[min(step, n) - 1] < x:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1

    # Бинарный поиск в найденном блоке
    while arr[prev] < x:
        prev += 1
        if prev == min(step, n):
            return -1

    # Проверка, найден ли элемент
    if arr[prev] == x:
        return prev

    return -1

# Пример использования
if __name__ == "__main__":
    # Создаем отсортированный массив
    array = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

    # Искомое значение
    x = 55

    # Выполняем поиск
    result = jump_search(array, x)

    if result != -1:
        print(f"Элемент {x} найден на позиции {result}")
    else:
        print(f"Элемент {x} не найден в массиве")

После запуска программы на экране появится следующий результат:
Элемент 55 найден на позиции 10

5) экспоненциальный поиск
def exponential_search(arr, target):
    """
    Экспоненциальный поиск + бинарный. Сложность: O(log n)
    """
    if arr[0] == target:
        return 0

    n = len(arr)
    i = 1
    while i < n and arr[i] <= target:
        i *= 2

    # Бинарный поиск в найденном диапазоне
    left = i // 2
    right = min(i, n - 1)
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
программа выведит 
Массив: [2, 5, 8, 12, 16, 23, 38, 45, 67, 73]
Поиск 45 : индекс 7
