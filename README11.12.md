Задание 3: Time Series Prediction (Прогнозирование временных рядов)
Задача: создать LSTM сеть для прогнозирования цен акций.
Требования:
- Использовать скользящее окно для подготовки данных
- Архитектура: LSTM(50) → Dense(25) → Dense(1)
- Нормализация данных
Код-заготовка (Python):
class TimeSeriesPredictor:
 def __init__(self, window_size=60):
 self.window_size = window_size
 # TODO: Создать модель с LSTM слоями
 pass

 def prepare_data(self, data):
 # TODO: Создать скользящие окна из данных
 # Вход: [t-window_size, ..., t-1]
 # Выход: [t]
 pass

 def normalize(self, data):
 # TODO: Нормализовать данные (Min-Max scaling)
 pass

 def train(self, data, epochs=50):
 # TODO: Обучить модель
 pass

 def predict(self, last_window):
 # TODO: Предсказать следующее значение
 pass
# Что нужно дополнить:
# 1. Реализацию LSTM ячейки
# 2. Создание скользящих окон
# 3. Нормализацию и денормализацию
# 4. Визуализацию предсказаний

___________________________________________________________________________
2) Алгоритм работы нейронной сети по блокам:
1. Инициализация:

Определяются ключевые параметры сети, включая размер окна (window_size) и инициализируется объект для масштабирования данных (scaler).

Объект самой модели (model) изначально пуст и создается позже методом create_model().

2. Создание модели:
 
Метод create_model() создает последовательность слоев нейронной сети:

а)LSTM слой с 50 ячейками памяти.

б)Полносвязный слой с активацией ReLU, содержащий 25 нейронов.

в)Выходной слой с одним нейроном

Модель компилируется с оптимизатором Adam и функцией потерь MSE (Mean Square Error).

3. Подготовка данных:

Метод prepare_data() принимает массив данных и формирует пары вход-выход с использованием скользящего окна.

Например, если длина окна равна 60, каждая точка входа включает предыдущие 60 элементов, а целью служит последующий элемент ряда.

4.Нормализация данных:

Данные предварительно обрабатываются с помощью Min-Max Scaler для приведения их к диапазону 
[0,1], что улучшает производительность сети.

5.Обучение модели:

Метод train() нормализует данные, готовит обучающую выборку и вызывает метод обучения сети.
Используется валидная доля данных (20%) для мониторинга прогресса обучения.

6.Прогнозирование:

После завершения обучения метод predict() позволяет сделать прогноз для новых данных.
Сначала применяется та же процедура нормализации, затем выполняется прогноз, и результат денормируется обратно в оригинальный масштаб.

7.Визуализация:
Во время обучения выводится график изменения функций потерь (train и validation loss), что помогает отслеживать прогресс и стабильность модели.

_____________________________________________________________

3) Что такое теорема Ардена и для чего она используется?

Теорема Ардена — формула для решения уравнений вида X = A·X + B в теории автоматов и формальных языков.


Решение:
X = A*·B

(при условии, что язык A не содержит пустой строки ε)


Для чего используется:


Преобразование автоматов в регулярные выражения — главное применение.

Решение систем уравнений для состояний конечных автоматов.

Построение лексических анализаторов (в компиляторах).


Простой пример:

Уравнение: X = 0·X + 1

Решение: X = 0*·1 (язык: {1, 01, 001, 0001, ...})


Фактически это инструмент для "развязывания" рекурсивных определений в регулярных выражениях. 

