Блочная (корзинная) сортировка
1. Определение алгоритма
Блочная (корзинная) сортировка — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
________________________________________
2. Принцип работы:
	Определяется количество корзин (например, по диапазону значений элементов):
bucket_count = len(arr)
buckets = [[] for _ in range(bucket_count)]
	Каждый элемент помещается в корзину согласно функции распределения:
index = int((num - min_val) / (max_val - min_val) * (bucket_count - 1))
buckets[index].append(num)
	Содержимое каждой корзины сортируется индивидуально:sorted_bucket = sorted(bucket)
	Корзины соединяются в порядке увеличения диапазона:sorted_arr.extend(sorted_bucket)

3. Оценка временной сложности
	Лучший случай (равномерное распределение элементов):Временная сложность равна O(N), где N — количество элементов в массиве. Это достигается, когда элементы равномерно распределены по корзинам, и каждая корзина содержит небольшое количество элементов.
	Средний случай:Временная сложность также равна O(N), если распределение элементов достаточно равномерное.
	Худший случай (все элементы в одной корзине):Временная сложность ухудшается до O(N^2), если все элементы попадают в одну корзину, и для сортировки корзины используется алгоритм с квадратичной сложностью (например, сортировка вставками).
________________________________________
4. Краткое объяснение оценки
	В лучшем случае, когда элементы равномерно распределены по корзинам, каждая корзина содержит небольшое количество элементов, и их сортировка выполняется быстро.
	В худшем случае, когда все элементы попадают в одну корзину, алгоритм сводится к сортировке одного большого массива, что приводит к квадратичной сложности.
Блинная сортировка 
1. Определение алгоритма
Блинная сортировка (Pancake Sort) — это алгоритм сортировки, который использует только операцию переворота (flip) для сортировки массива. Операция переворота заключается в том, что элементы массива переворачиваются (меняются местами) от начала до заданной позиции. Алгоритм работает путем последовательного нахождения максимального элемента в несортированной части массива и переворачивания его на первую позицию, а затем переворачивания всей несортированной части массива, чтобы максимальный элемент оказался на своем месте.
________________________________________
2. Принцип работы:
	Поиск максимального элемента в несортированной части массива:max_index = arr.index(max(arr[:unsorted_length]))
	Переворот массива до максимального элемента (если он не на первой позиции):
	if max_index != 0:   
	     arr[:max_index + 1] = reversed(arr[:max_index + 1])
	Переворот всей несортированной части массива, чтобы максимальный элемент оказался на своем месте:arr[:unsorted_length] = reversed(arr[:unsorted_length])
	Уменьшение длины несортированной части массива:unsorted_length -= 1
________________________________________
3. Оценка временной сложности
	Лучший случай:Временная сложность равна O(N), где N — количество элементов в массиве. Это достигается, когда массив уже отсортирован или почти отсортирован.
	Средний и худший случаи:Временная сложность равна O(N^2), так как для каждого элемента массива требуется найти максимальный элемент и выполнить два переворота.
________________________________________
4. Краткое объяснение оценки
	В лучшем случае, когда массив уже отсортирован, алгоритм выполняет минимальное количество операций переворота.
	В худшем случае, когда массив отсортирован в обратном порядке, для каждого элемента требуется найти максимальный элемент и выполнить два переворота, что приводит к квадратичной сложности.
сортировка бусинами (гравитационная)
1. Определение алгоритма
Сортировка бусинами (Bead Sort) — это алгоритм сортировки, который использует аналогию с бусинами на вертикальных стержнях. Каждый элемент массива представлен как количество бусин на соответствующем стержне. Алгоритм работает путем "падения" бусин вниз, что приводит к сортировке массива.
________________________________________
2. Принцип работы:
	Создание вертикальных стержней:
	beads = [[1 if arr[i] > j else 0 for j in range(max(arr))] for i in range(len(arr))]
	"Падение" бусин вниз:
for i in range(len(beads[0])): 
  count = sum(beads[j][i] for j in range(len(beads)))  
   for j in range(len(beads)):      
        beads[j][i] = 1 if j < count else 0
	Преобразование обратно в массив:
sorted_arr = [sum(beads[i]) for i in range(len(beads))]
________________________________________
3. Оценка временной сложности
	Лучший, средний и худший случаи:Временная сложность равна O(N×M), где N — количество элементов в массиве, а M — максимальное значение в массиве. Это связано с тем, что для каждого элемента массива требуется пройти по всем вертикальным стержням.
________________________________________
4. Краткое объяснение оценки
	Временная сложность зависит от количества элементов и максимального значения в массиве. Чем больше максимальное значение, тем больше времени требуется для "падения" бусин.
поиск скачками
1. Определение алгоритма
Поиск скачками (Jump Search) — это алгоритм поиска в отсортированном массиве, который использует стратегию "скачков" для быстрого нахождения элемента. Алгоритм работает путем последовательного "прыжка" на фиксированное количество шагов, пока не будет найден элемент, который больше или равен искомому значению. Затем выполняется бинарный поиск в диапазоне между последним "прыжком" и текущим положением.
________________________________________
2. Принцип работы:
	Определение шага прыжка:step = int(math.sqrt(len(arr)))
	Поиск блока, где может находиться искомый элемент:prev = 0while arr[min(step, len(arr)) - 1] < x:    prev = step    step += int(math.sqrt(len(arr)))    if prev >= len(arr):        return -1
	Бинарный поиск в найденном блоке:while arr[prev] < x:    prev += 1    if prev == min(step, len(arr)):        return -1
	Проверка, найден ли элемент:if arr[prev] == x:    return prev
________________________________________
3. Оценка временной сложности
	Лучший случай:Временная сложность равна O(√N), где N — количество элементов в массиве. Это достигается, когда элемент находится в начале массива.
	Средний и худший случаи:Временная сложность также равна O(√N), так как алгоритм выполняет "прыжки" и бинарный поиск в найденном блоке.
________________________________________
4. Краткое объяснение оценки
	Временная сложность зависит от размера массива и шага прыжка. Чем больше массив, тем больше времени требуется для "прыжков" и бинарного поиска.
ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК (EXPONENTIAL SEARCH)

1)Описание алгоритма:  
Быстрое определение диапазона через экспоненциальное расширение границ с последующим бинарным поиском.

2)Принцип работы:
 Экспоненциальное расширение: while i < n and arr[i] <= target
 Удвоение границы: i *= 2
 Бинарный поиск: while left <= right с mid = (left + right) // 2

Оценка временной сложности
	Лучший случай:Временная сложность равна O(log⁡N), где N — количество элементов в массиве. Это достигается, когда элемент находится в начале массива.
	Средний и худший случаи:Временная сложность также равна O(log⁡N), так как алгоритм выполняет "скачки" и бинарный поиск в найденном блоке.
________________________________________
4. Краткое объяснение оценки
	Временная сложность зависит от размера массива и шага поиска. Чем больше массив, тем больше времени требуется для "скачков" и бинарного поиска
